/**
 * pivotSQLGenerator - Generate safe SQL queries from pivot configuration
 *
 * SECURITY CRITICAL: All user inputs MUST be escaped using buildSafeFQN()
 * and escapeStringValue() to prevent SQL injection.
 *
 * Strategy:
 * 1. Build SELECT clause with aggregations
 * 2. Build FROM clause with source table
 * 3. Build WHERE clause from filters
 * 4. Build GROUP BY clause from rows + columns
 * 5. Add PIVOT transformation if columns exist (using CASE WHEN)
 * 6. Apply ORDER BY and LIMIT for safety
 */

import { buildSafeFQN, escapeStringValue } from './queryHelpers';

/**
 * Escape identifier (column/table name) with double quotes
 */
function escapeIdentifier(identifier) {
  return `"${identifier}"`;
}

/**
 * Build aggregation expression based on function type
 */
export function buildAggregationExpression(valueConfig) {
  const field = escapeIdentifier(valueConfig.fieldName);
  const agg = valueConfig.aggregation || 'COUNT';

  switch (agg) {
    case 'COUNT':
      return `COUNT(${field})`;

    case 'COUNT_DISTINCT':
      return `COUNT(DISTINCT ${field})`;

    case 'SUM':
      return `SUM(${field})`;

    case 'AVG':
      return `AVG(${field})`;

    case 'MIN':
      return `MIN(${field})`;

    case 'MAX':
      return `MAX(${field})`;

    case 'MEDIAN':
      return `MEDIAN(${field})`;

    case 'STDDEV':
      return `STDDEV(${field})`;

    case 'VARIANCE':
      return `VARIANCE(${field})`;

    case 'PERCENTILE_CONT':
      const percentile = valueConfig.percentileValue || 0.5;
      return `PERCENTILE_CONT(${percentile}) WITHIN GROUP (ORDER BY ${field})`;

    default:
      // Safe default
      return `COUNT(${field})`;
  }
}

/**
 * Build WHERE clause from filter configurations
 */
export function buildWhereClause(filters) {
  if (!filters || filters.length === 0) return '';

  const conditions = filters.map(f => {
    const field = escapeIdentifier(f.fieldName);

    switch (f.operator) {
      case 'EQUALS':
        return `${field} = ${escapeStringValue(f.values[0])}`;

      case 'NOT_EQUALS':
        return `${field} != ${escapeStringValue(f.values[0])}`;

      case 'IN':
        const inValues = f.values.map(v => escapeStringValue(v)).join(', ');
        return `${field} IN (${inValues})`;

      case 'NOT_IN':
        const notInValues = f.values.map(v => escapeStringValue(v)).join(', ');
        return `${field} NOT IN (${notInValues})`;

      case 'GREATER_THAN':
        return `${field} > ${Number(f.values[0])}`;

      case 'LESS_THAN':
        return `${field} < ${Number(f.values[0])}`;

      case 'BETWEEN':
        return `${field} BETWEEN ${Number(f.values[0])} AND ${Number(f.values[1])}`;

      case 'IS_NULL':
        return `${field} IS NULL`;

      case 'IS_NOT_NULL':
        return `${field} IS NOT NULL`;

      case 'CONTAINS':
        return `${field} ILIKE ${escapeStringValue('%' + f.values[0] + '%')}`;

      default:
        return `${field} = ${escapeStringValue(f.values[0])}`;
    }
  });

  return conditions.join(' AND ');
}

/**
 * Generate SQL query from pivot configuration
 *
 * @param {Object} config - Pivot configuration state
 * @returns {string} Generated SQL query
 */
export function generatePivotSQL(config) {
  const { source, rows, columns, values, filters, options } = config;
  const { database, schema, table } = source;

  // Validation: require source table
  if (!database || !schema || !table) {
    throw new Error('Database, schema, and table are required');
  }

  // Validation: require at least one aggregation
  if (!values || values.length === 0) {
    throw new Error('At least one value (measure) is required');
  }

  // Build safe fully-qualified table name
  const fqn = buildSafeFQN(database, schema, table);

  // Build WHERE clause from filters
  const whereClause = buildWhereClause(filters);

  // Build aggregation expressions
  const aggregations = values.map(v => {
    const expr = buildAggregationExpression(v);
    const alias = escapeIdentifier(v.alias || v.fieldName.toLowerCase());
    return `${expr} AS ${alias}`;
  }).join(',\n    ');

  // Build GROUP BY dimensions (rows + columns)
  const dimensions = [...rows, ...columns].map(d => escapeIdentifier(d.fieldName));

  // Build ORDER BY clause from rows
  const orderBy = rows.length > 0
    ? rows.map(r => {
        const field = escapeIdentifier(r.fieldName);
        const direction = r.order || 'ASC';
        return `${field} ${direction}`;
      }).join(', ')
    : '';

  // For MVP: Simple GROUP BY query (no column pivoting yet)
  // Column pivoting will be added in Phase 2

  const rowFields = rows.length > 0
    ? rows.map(r => escapeIdentifier(r.fieldName)).join(',\n    ') + ','
    : '';

  const sql = `
-- Pivot Query
-- Generated by MDLH Pivot Builder
SELECT
    ${rowFields}
    ${aggregations}
FROM ${fqn}
${whereClause ? 'WHERE ' + whereClause : ''}
${dimensions.length > 0 ? 'GROUP BY ' + dimensions.join(', ') : ''}
${orderBy ? 'ORDER BY ' + orderBy : ''}
LIMIT ${options.limitRows || 1000};
  `.trim();

  return sql;
}

/**
 * Validate pivot configuration before SQL generation
 */
export function validatePivotConfig(config) {
  const errors = [];

  if (!config.source.database) {
    errors.push('Database is required');
  }

  if (!config.source.schema) {
    errors.push('Schema is required');
  }

  if (!config.source.table) {
    errors.push('Table is required');
  }

  if (!config.values || config.values.length === 0) {
    errors.push('At least one measure (value) is required');
  }

  // Validate aggregation functions
  const validAggregations = [
    'COUNT', 'COUNT_DISTINCT', 'SUM', 'AVG', 'MIN', 'MAX',
    'MEDIAN', 'STDDEV', 'VARIANCE', 'PERCENTILE_CONT'
  ];

  config.values?.forEach(v => {
    if (!validAggregations.includes(v.aggregation)) {
      errors.push(`Invalid aggregation function: ${v.aggregation}`);
    }
  });

  return {
    valid: errors.length === 0,
    errors,
  };
}

export default {
  generatePivotSQL,
  validatePivotConfig,
  buildAggregationExpression,
  buildWhereClause,
};
