// ============================================
// EXPORT ENGINE
// Export priorities and recommendations in various formats
// ============================================

import type {
  Priority,
  ImplementationPlan,
  ExportConfig,
} from '../types/priority';

/**
 * Export priorities and recommendations
 */
export function exportPriorities(
  priorities: Priority[],
  config: ExportConfig
): string {
  switch (config.format) {
    case 'json':
      return exportAsJson(priorities);

    case 'csv':
      return exportAsCsv(priorities, config);

    case 'markdown':
      return generateMarkdownReport(priorities, config);

    case 'atlan-bulk':
      return generateAtlanBulkUpdate(priorities);

    default:
      throw new Error(`Unknown format: ${config.format}`);
  }
}

function exportAsJson(priorities: Priority[]): string {
  return JSON.stringify(priorities, null, 2);
}

function exportAsCsv(priorities: Priority[], config: ExportConfig): string {
  const headers = ['Field', 'Priority', 'Score', 'Label'];
  if (config.includeReasons) headers.push('Reasoning');

  const escapeCell = (value: unknown) => {
    const str = String(value ?? '');
    // RFC 4180: escape quotes by doubling them
    const escaped = str.replace(/"/g, '""');
    return `"${escaped}"`;
  };

  const rows = priorities.map(p => {
    const row = [p.field, p.level, p.score.toString(), p.label];
    if (config.includeReasons) row.push(p.reasoning.join('; '));
    return row.map(escapeCell).join(',');
  });

  return [headers.join(','), ...rows].join('\n');
}

function generateMarkdownReport(priorities: Priority[], config: ExportConfig): string {
  let md = '# Metadata Model Priorities\n\n';
  md += `_Generated on ${new Date().toISOString().slice(0, 10)}_\n\n`;

  // Summary table
  md += '## Priority Summary\n\n';
  md += '| Priority | Field | Score | Status |\n';
  md += '|----------|-------|-------|--------|\n';

  for (const p of priorities) {
    md += `| ${p.badge} ${p.level} | ${p.field} | ${p.score} | ${p.label} |\n`;
  }

  // Detailed reasoning if requested
  if (config.includeReasons) {
    md += '\n## Detailed Reasoning\n\n';
    for (const p of priorities) {
      md += `### ${p.field}\n\n`;
      md += `**Priority:** ${p.level} (Score: ${p.score})\n\n`;
      if (p.reasoning.length > 0) {
        md += '**Factors:**\n';
        for (const reason of p.reasoning) {
          md += `- ${reason}\n`;
        }
      }
      md += '\n';
    }
  }

  // Priority breakdown
  md += '## Priority Breakdown\n\n';
  const p0 = priorities.filter(p => p.level === 'P0');
  const p1 = priorities.filter(p => p.level === 'P1');
  const p2 = priorities.filter(p => p.level === 'P2');
  const p3 = priorities.filter(p => p.level === 'P3');

  if (p0.length > 0) {
    md += `### Critical (P0) - ${p0.length} items\n`;
    p0.forEach(p => { md += `- ${p.field}\n`; });
    md += '\n';
  }

  if (p1.length > 0) {
    md += `### High (P1) - ${p1.length} items\n`;
    p1.forEach(p => { md += `- ${p.field}\n`; });
    md += '\n';
  }

  if (p2.length > 0) {
    md += `### Medium (P2) - ${p2.length} items\n`;
    p2.forEach(p => { md += `- ${p.field}\n`; });
    md += '\n';
  }

  if (p3.length > 0) {
    md += `### Low (P3) - ${p3.length} items\n`;
    p3.forEach(p => { md += `- ${p.field}\n`; });
    md += '\n';
  }

  return md;
}

function generateAtlanBulkUpdate(priorities: Priority[]): string {
  // Generate PyAtlan SDK code for bulk updates
  const priorityData = priorities.map(p => ({
    field: p.field,
    priority: p.level,
    score: p.score,
  }));

  const code = `# PyAtlan Bulk Update Template
# Generated by Metadata Model Designer

from pyatlan.client.atlan import AtlanClient
from pyatlan.model.assets import Asset

client = AtlanClient()

# Priority-based update queue
priority_updates = ${JSON.stringify(priorityData, null, 2)}

# Example: Get assets missing high-priority fields
def get_assets_missing_field(field_name: str, limit: int = 100):
    """Query for assets missing the specified field."""
    # Implementation depends on your specific Atlan setup
    pass

# Example: Bulk update owner for assets
def bulk_assign_owner(assets: list, owner_guid: str):
    """Assign owner to multiple assets."""
    for asset in assets:
        asset.owner_users = [owner_guid]

    # Batch save
    client.asset.save(assets)

# Process priorities in order
for priority in priority_updates:
    field = priority['field']
    level = priority['priority']

    if level in ['P0', 'P1']:
        print(f"Processing {level} priority: {field}")
        # Add your implementation here
        pass
`;

  return code;
}

/**
 * Export implementation plan
 */
export function exportImplementationPlan(plan: ImplementationPlan): string {
  let md = `# Implementation Plan: ${plan.pattern.name}\n\n`;

  // Overview
  md += '## Overview\n\n';
  md += `**Pattern:** ${plan.pattern.name}\n`;
  md += `**Description:** ${plan.pattern.description}\n`;
  md += `**Use Case:** ${plan.pattern.useCase}\n\n`;
  md += `**Current Match Score:** ${plan.currentMatchScore}%\n`;
  md += `**Estimated Timeline:** ${plan.totalEstimatedWeeks} weeks\n\n`;

  // Prerequisites
  if (plan.pattern.prerequisites.length > 0) {
    md += '## Prerequisites\n\n';
    for (const prereq of plan.pattern.prerequisites) {
      md += `- [ ] ${prereq}\n`;
    }
    md += '\n';
  }

  // Phases
  md += '## Implementation Phases\n\n';

  for (let i = 0; i < plan.phases.length; i++) {
    const phase = plan.phases[i];
    md += `### Phase ${i + 1}: ${phase.name}\n\n`;
    md += `${phase.description}\n\n`;
    md += `**Timeline:** ${phase.estimatedWeeks} weeks\n`;
    md += `**Milestone:** ${phase.milestone}\n\n`;

    if (phase.fields.length > 0) {
      md += '**Fields to address:**\n';
      for (const field of phase.fields) {
        const patternField = plan.pattern.fields.find(f => f.field === field);
        md += `- [ ] ${field}`;
        if (patternField) {
          md += ` - ${patternField.rationale}`;
        }
        md += '\n';
      }
      md += '\n';
    }
  }

  // Success criteria
  md += '## Success Criteria\n\n';
  md += `- [ ] All required fields at 70%+ coverage\n`;
  md += `- [ ] Pattern match score at 100%\n`;
  md += `- [ ] No critical validation issues\n`;

  return md;
}

/**
 * Export audit summary
 */
export function exportAuditSummary(
  fieldCoverage: { field: string; coveragePercent: number }[],
  format: 'json' | 'csv' | 'markdown'
): string {
  switch (format) {
    case 'json':
      return JSON.stringify(fieldCoverage, null, 2);

    case 'csv':
      {
        const headers = 'Field,Coverage';
        const rows = fieldCoverage.map(f =>
          `"${f.field}","${(f.coveragePercent * 100).toFixed(1)}%"`
        );
        return [headers, ...rows].join('\n');
      }

    case 'markdown':
      {
        let md = '# Field Coverage Summary\n\n';
        md += '| Field | Coverage |\n';
        md += '|-------|----------|\n';
        for (const f of fieldCoverage) {
          const bar = '█'.repeat(Math.round(f.coveragePercent * 10)) +
                     '░'.repeat(10 - Math.round(f.coveragePercent * 10));
          md += `| ${f.field} | ${bar} ${(f.coveragePercent * 100).toFixed(1)}% |\n`;
        }
        return md;
      }

    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * Create downloadable blob
 */
export function createDownloadBlob(content: string, mimeType: string): Blob {
  return new Blob([content], { type: mimeType });
}

/**
 * Trigger file download in browser
 */
export function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = createDownloadBlob(content, mimeType);
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Get mime type for export format
 */
export function getMimeType(format: ExportConfig['format']): string {
  const mimeTypes: Record<ExportConfig['format'], string> = {
    json: 'application/json',
    csv: 'text/csv',
    markdown: 'text/markdown',
    'atlan-bulk': 'text/x-python',
  };
  return mimeTypes[format];
}

/**
 * Get file extension for export format
 */
export function getFileExtension(format: ExportConfig['format']): string {
  const extensions: Record<ExportConfig['format'], string> = {
    json: 'json',
    csv: 'csv',
    markdown: 'md',
    'atlan-bulk': 'py',
  };
  return extensions[format];
}
